<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Squidstat API User Manual: Remote access to Squidstat</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Admiral_Instruments_Logo.webp"/></td>
  <td id="projectalign">
   <div id="projectname">Squidstat API User Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_intro_and_examples_6__squidstat_on_remote_computer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Remote access to Squidstat </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="remotesquidstat"></a></p>
<h3><a class="anchor" id="autotoc_md20"></a>
Introduction</h3>
<p >Although the Squidstat cannot directly communicate over a network, it is possible to create a simple server-client interface that can allow a remote computer to configure and run experiments over a network. In this example, we will set up a server and client via Python's socket library and run a predefined Open Circuit Potential experiment with a variable <code>duration</code> specified by a client. The server will be responsible for managing the Squidstat. When the experiment finishes, both the client and the server terminate. The full example can be found at both the bottom of this page and in the example folder of the API. <br  />
 <em>Note: This example assumes that the Squidstat is already running the appropriate firmware already and so it does not cover updating the firmware.</em></p>
<h3><a class="anchor" id="autotoc_md21"></a>
Server Implementation</h3>
<p >Toward the beginning of our server file, we have some definitions that you will need to change accordingly to match your settings: <br  />
 The first two will define the address and port that the server listens on. They should match the ones in the client file (See Client Implementation). <br  />
 A few notes:</p><ol type="1">
<li>This example assumes that the server and client are both on the same computer. That will almost certainly not be the case for your system, so you will need to change these to match your local connection. For example, if your server computer is located at <code>10.0.1.5</code> that is the address you will use here.</li>
<li>The port must not be in use by another program running on the server.</li>
<li>If your server and client are not located on local networks (E.G. behind a NAT router over an ISP's network) you will most likely need to portforward your chosen port on your router.</li>
<li>A firewall may block incoming connections from other network devices. If you are having connection issues, you should try adding an exception to the firewall for this program at the chosen port. <div class="fragment"><div class="line"># Define the server address and port</div>
<div class="line">HOST = &#39;localhost&#39;</div>
<div class="line">PORT = 12345</div>
</div><!-- fragment --> These represent how the server will communicate with the Squidstat. They must match the Squidstat's COM port and serial number. On Windows the COM port can be found through device manager. <div class="fragment"><div class="line"># The comport the Squidstat is connected to</div>
<div class="line">SQUIDCOMPORT = &quot;COM4&quot;</div>
<div class="line">SQUIDNAME = &quot;Plus1700&quot;</div>
</div><!-- fragment --></li>
</ol>
<p ><code>start_ocp_experiment</code> will create and start an Open Circuit Potential experiment on channel 1 of the Squidstat. The duration is passed in via the duration variable. This function will be called when the client sends a <code>startExperiment</code> command. </p><div class="fragment"><div class="line"># This will build a start the Open Circuit Potential experiment</div>
<div class="line">def start_ocp_experiment(handler, durationSec=60):</div>
<div class="line">    # Create an experiment with elements</div>
<div class="line">    experiment = AisExperiment()</div>
<div class="line">    ocpElement = AisOpenCircuitElement(durationSec, 1)</div>
<div class="line"> </div>
<div class="line">    experiment.appendElement(ocpElement, 1)</div>
<div class="line"> </div>
<div class="line">    # Upload the experiment to channel 0</div>
<div class="line">    error = handler.uploadExperimentToChannel(0, experiment)</div>
<div class="line">    if error.value() != AisErrorCode.ErrorCode.Success:</div>
<div class="line">        return error</div>
<div class="line"> </div>
<div class="line">    # Start the experiment</div>
<div class="line">    return(handler.startUploadedExperiment(0))</div>
</div><!-- fragment --><p ><code>command_to_device</code> is the function that controls the communication to the Squidstat. It takes in a command as plain text which determines how the software will interact with the Squidstat. You may optionally choose to uncomment the print statements to make the server more verbose. </p><div class="fragment"><div class="line"># Send a specified command to our Squidstat</div>
<div class="line">def command_to_device(command, handler):</div>
<div class="line">    #Check if we had an argument associated with the command</div>
<div class="line">    splitCommand = command.split(&quot; &quot;)</div>
<div class="line">    action = splitCommand[0]</div>
<div class="line">    actionArg = 0</div>
<div class="line">    if(len(splitCommand) &gt; 1):</div>
<div class="line">        try:</div>
<div class="line">            actionArg = int(splitCommand[1])</div>
<div class="line">        except:</div>
<div class="line">            actionArg = 0</div>
<div class="line"> </div>
<div class="line">    response = None</div>
<div class="line">    if action == &#39;startExperiment&#39;:</div>
<div class="line">        #print(&quot;Starting experiment...&quot;)</div>
<div class="line">        response = start_ocp_experiment(handler, actionArg)</div>
<div class="line">    elif action == &#39;stopExperiment&#39;:</div>
<div class="line">        #print(&quot;Stopping experiment...&quot;)</div>
<div class="line">        response = handler.stopExperiment(0)</div>
<div class="line">    else:</div>
<div class="line">        #print(&quot;Invalid command:&quot;, command)</div>
<div class="line">        pass</div>
<div class="line">    return response</div>
</div><!-- fragment --><p ><code>handle_client</code> listens for commands from the client. Once the client has established a connection, it will loop until either the program terminates, typically through experiment completion, or the client drops the session. </p><div class="fragment"><div class="line"># Listen for the client&#39;s messages, and disconnect signals and terminate program when finished</div>
<div class="line">def handle_client(handler, client_socket):</div>
<div class="line">    print(&quot;Client connected&quot;)</div>
<div class="line"> </div>
<div class="line">    while True:</div>
<div class="line">        # Receive data from the client</div>
<div class="line">        try:</div>
<div class="line">            data = client_socket.recv(1024).decode()</div>
<div class="line">        except ConnectionResetError:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">        # Check if the client has closed the connection</div>
<div class="line">        if not data:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">        # Handle the command</div>
<div class="line">        handle_command(data, handler, client_socket)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    handler.activeDCDataReady.disconnect()</div>
<div class="line">    handler.activeACDataReady.disconnect()</div>
<div class="line">    handler.experimentNewElementStarting.disconnect()</div>
<div class="line">    handler.experimentStopped.disconnect()</div>
<div class="line">    command_to_device(&quot;stopExperiment&quot;, handler)</div>
<div class="line">    # Close the client socket</div>
<div class="line">    client_socket.close()</div>
<div class="line">    print(&quot;Client disconnected&quot;)</div>
<div class="line">    os._exit(1)</div>
</div><!-- fragment --><p> <code>send_data_to_client</code> is the transmission function for all data that is coming from the experiments. These are hooked up via a QT signal/slot connection. This function is called each time the device sends a signal that there is information ready to be processed. event_type is our hint as to which type of data/message we are processing. </p><div class="fragment"><div class="line">def send_data_to_client(client_socket, event_type, data):</div>
<div class="line">    if event_type == &quot;DCData&quot;:</div>
<div class="line">        message = &quot;timestamp: {:.9f}, workingElectrodeVoltage: {:.9f}&quot;.format(data.timestamp, data.workingElectrodeVoltage)</div>
<div class="line">    elif event_type == &quot;ACData&quot;:</div>
<div class="line">        message = &quot;frequency: {:.9f}, absoluteImpedance: {:.9f}, phaseAngle: {:.9f}&quot;.format(data.frequency, data.absoluteImpedance, data.phaseAngle)</div>
<div class="line">    elif event_type == &quot;NewElement&quot;:</div>
<div class="line">        message = &quot;New Node beginning: {}, step number: {}, step sub: {}&quot;.format(data.stepName, data.stepNumber, data.substepNumber)</div>
<div class="line">    elif event_type == &quot;ExperimentCompleted&quot;:</div>
<div class="line">        message = &quot;Experiment Completed: {}&quot;.format(data)</div>
<div class="line">    else:</div>
<div class="line">        return</div>
<div class="line"> </div>
<div class="line">    client_socket.send(message.encode())</div>
</div><!-- fragment --><p >Here we establish our connection to the Squidstat and print out any error that may result when attempting it. </p><div class="fragment"><div class="line"># Create the device tracker and connect to the Squidstat we will be using</div>
<div class="line">print(f&quot;Attempting to connect to the Squidstat {SQUIDNAME} on {SQUIDCOMPORT}...&quot;)</div>
<div class="line">tracker = AisDeviceTracker.Instance()</div>
<div class="line">tracker.newDeviceConnected.connect(lambda deviceName: print(&quot;Device is Connected: %s&quot; % deviceName))</div>
<div class="line">error = tracker.connectToDeviceOnComPort(SQUIDCOMPORT)</div>
<div class="line"> </div>
<div class="line">if error.value() != AisErrorCode.ErrorCode.Success:</div>
<div class="line">    print(error.message())</div>
<div class="line">    exit()</div>
<div class="line"> </div>
<div class="line"># Create the instrument handler</div>
<div class="line">handler = tracker.getInstrumentHandler(SQUIDNAME)</div>
<div class="line">print(&quot;Connection successful\n&quot;)</div>
</div><!-- fragment --><p >We then open the server port, accept our client, and set up the QT connections. Our client listener <code>handle_client</code> is sent to execute on its own thread. </p><div class="fragment"><div class="line"># Create the TCP/IP socket and bind it to our host</div>
<div class="line">print(&quot;Starting server...&quot;)</div>
<div class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div>
<div class="line">activeSockets.append(server_socket)</div>
<div class="line">server_socket.bind((HOST, PORT))</div>
<div class="line"> </div>
<div class="line"># Listen for incoming connections</div>
<div class="line">server_socket.listen(1)</div>
</div><!-- fragment --><p> ... </p><div class="fragment"><div class="line"># Accept a client connection</div>
<div class="line">client_socket, client_address = server_socket.accept()</div>
<div class="line">activeSockets.append(client_socket)</div>
<div class="line"> </div>
<div class="line"># Connect the signals to send data to the client</div>
<div class="line">handler.activeDCDataReady.connect(lambda channel, data: send_data_to_client(client_socket, &quot;DCData&quot;, data))</div>
<div class="line">handler.activeACDataReady.connect(lambda channel, data: send_data_to_client(client_socket, &quot;ACData&quot;, data))</div>
<div class="line">handler.experimentNewElementStarting.connect(lambda channel, data: send_data_to_client(client_socket, &quot;NewElement&quot;, data))</div>
<div class="line">handler.experimentStopped.connect(lambda channel: send_data_to_client(client_socket, &quot;ExperimentCompleted&quot;, channel))</div>
<div class="line"> </div>
<div class="line"># Start the listening process in a separate thread</div>
<div class="line">listening_thread = threading.Thread(target=handle_client, args=(handler, client_socket))</div>
<div class="line">listening_thread.start()</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Client Implementation</h3>
<p >In this section we will go over some of the functional aspects of the client.</p>
<p >At the beginning of the client file, we have some definitions that must mirror the server. See Server Implementation for more details. </p><div class="fragment"><div class="line">SERVER_HOST = &quot;localhost&quot;</div>
<div class="line">SERVER_PORT = 12345</div>
</div><!-- fragment --><p ><code>send_command</code> is exactly as it sounds. Once we establish the connection to the server, this function sends our commands to the server, listens to the response, and prints it. Note that this is somewhat different from the listening thread that prints the remote Squidstat's active data. This example assumes that all commands are sent prior to sending the startExperiment command, and calling this function after the start of the experiment can cause unexpected behavior due to having two <code>recv</code> functions running at the same time. </p><div class="fragment"><div class="line">def send_command(command):</div>
<div class="line">    # Send the command to the server</div>
<div class="line">    try:</div>
<div class="line">        client_socket.send(command.encode())</div>
<div class="line">    except:</div>
<div class="line">        print(&quot;Connection was closed by host&quot;)</div>
<div class="line">        os._exit(1)</div>
<div class="line"> </div>
<div class="line">    # Receive and print the response from the server</div>
<div class="line">    response = client_socket.recv(1024).decode()</div>
<div class="line">    print(&quot;Server response:&quot;, response)</div>
</div><!-- fragment --><p >Establish our connection to the server. If the server is not running or some problem occurs, we will terminate the program now. </p><div class="fragment"><div class="line">try:</div>
<div class="line">    client_socket.connect((SERVER_HOST, SERVER_PORT))</div>
<div class="line">except Exception as ex:</div>
<div class="line">    print(&quot;Unable to establish connection to server:\n%s&quot; % ex)</div>
<div class="line">    exit()</div>
</div><!-- fragment --><p >After we get the duration from the user at the terminal, we will kick off the experiment by sending the 'startExperiment' command to the server. At this point, the server will translate the message and call the appropriate function to notify the Squidstat. </p><div class="fragment"><div class="line">send_command(f&#39;startExperiment {duration}&#39;)</div>
</div><!-- fragment --><p >Finally, we start a loop that will listen to the server, which at this point will be transmitting the experiment data and the stop response. When we get the data we will simply print it, but this could be modified to any other data handling function. When we get the stop response we can break the loop which will terminate the program. </p><div class="fragment"><div class="line">while True:</div>
<div class="line">    try:</div>
<div class="line">        data = client_socket.recv(1024).decode()</div>
<div class="line">    except (ConnectionAbortedError, BrokenPipeError):</div>
<div class="line">        # This exception will be raised when the user presses &lt;ENTER&gt;</div>
<div class="line">        print(&quot;Finishing connection&quot;)</div>
<div class="line">        break</div>
<div class="line">    except ConnectionResetError:</div>
<div class="line">        print(&quot;The server closed the connection suddenly.&quot;)</div>
<div class="line">        break</div>
<div class="line"> </div>
<div class="line">    if not data:</div>
<div class="line">        break</div>
<div class="line"> </div>
<div class="line">    # Handle the data that was received.</div>
<div class="line">    print(data)</div>
<div class="line"> </div>
<div class="line">    if(&quot;Experiment Completed: &quot; in data):</div>
<div class="line">        break</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
Full Example</h3>
<h4><a class="anchor" id="autotoc_md24"></a>
TCP_Server.py</h4>
<div class="fragment"><div class="line">import os</div>
<div class="line">import socket</div>
<div class="line">import threading</div>
<div class="line">from PySide2.QtWidgets import QApplication</div>
<div class="line">from SquidstatPyLibrary import AisDeviceTracker</div>
<div class="line">from SquidstatPyLibrary import AisExperiment</div>
<div class="line">from SquidstatPyLibrary import AisOpenCircuitElement</div>
<div class="line">from SquidstatPyLibrary import AisErrorCode</div>
<div class="line"> </div>
<div class="line"># Define the server address and port</div>
<div class="line">HOST = &#39;localhost&#39;</div>
<div class="line">PORT = 12345</div>
<div class="line"> </div>
<div class="line"># The comport the Squidstat is connected to</div>
<div class="line">SQUIDCOMPORT = &quot;COM4&quot;</div>
<div class="line">SQUIDNAME = &quot;Plus1700&quot;</div>
<div class="line"> </div>
<div class="line"># Create the QT application</div>
<div class="line">app = QApplication([])</div>
<div class="line">activeSockets = []</div>
<div class="line"> </div>
<div class="line"># This will build a start the Open Circuit Potential experiment</div>
<div class="line">def start_ocp_experiment(handler, durationSec=60):</div>
<div class="line">    # Create an experiment with elements</div>
<div class="line">    experiment = AisExperiment()</div>
<div class="line">    ocpElement = AisOpenCircuitElement(durationSec, 1)</div>
<div class="line"> </div>
<div class="line">    experiment.appendElement(ocpElement, 1)</div>
<div class="line"> </div>
<div class="line">    # Upload the experiment to channel 0</div>
<div class="line">    error = handler.uploadExperimentToChannel(0, experiment)</div>
<div class="line">    if error.value() != AisErrorCode.ErrorCode.Success:</div>
<div class="line">        return error</div>
<div class="line"> </div>
<div class="line">    # Start the experiment</div>
<div class="line">    return(handler.startUploadedExperiment(0))</div>
<div class="line"> </div>
<div class="line"># Send a specified command to our Squidstat</div>
<div class="line">def command_to_device(command, handler):</div>
<div class="line">    #Check if we had an argument associated with the command</div>
<div class="line">    splitCommand = command.split(&quot; &quot;)</div>
<div class="line">    action = splitCommand[0]</div>
<div class="line">    actionArg = 0</div>
<div class="line">    if(len(splitCommand) &gt; 1):</div>
<div class="line">        try:</div>
<div class="line">            actionArg = int(splitCommand[1])</div>
<div class="line">        except:</div>
<div class="line">            actionArg = 0</div>
<div class="line"> </div>
<div class="line">    response = None</div>
<div class="line">    if action == &#39;startExperiment&#39;:</div>
<div class="line">        #print(&quot;Starting experiment...&quot;)</div>
<div class="line">        response = start_ocp_experiment(handler, actionArg)</div>
<div class="line">    elif action == &#39;stopExperiment&#39;:</div>
<div class="line">        #print(&quot;Stopping experiment...&quot;)</div>
<div class="line">        response = handler.stopExperiment(0)</div>
<div class="line">    else:</div>
<div class="line">        #print(&quot;Invalid command:&quot;, command)</div>
<div class="line">        pass</div>
<div class="line">    return response</div>
<div class="line"> </div>
<div class="line"># Handle commands from the client</div>
<div class="line">def handle_command(command, handler, client_socket):</div>
<div class="line">    # Send a response back to the client</div>
<div class="line">    responseMsg = &quot;Unknown Command&quot;</div>
<div class="line">    response = command_to_device(command, handler)</div>
<div class="line">    if(response != None):</div>
<div class="line">        responseMsg = response.message()</div>
<div class="line">    response = &quot;{}&quot;.format(responseMsg)</div>
<div class="line">    client_socket.send(response.encode())</div>
<div class="line"> </div>
<div class="line"># Listen for the client&#39;s messages, and disconnect signals and terminate program when finished</div>
<div class="line">def handle_client(handler, client_socket):</div>
<div class="line">    print(&quot;Client connected&quot;)</div>
<div class="line"> </div>
<div class="line">    while True:</div>
<div class="line">        # Receive data from the client</div>
<div class="line">        try:</div>
<div class="line">            data = client_socket.recv(1024).decode()</div>
<div class="line">        except ConnectionResetError:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">        # Check if the client has closed the connection</div>
<div class="line">        if not data:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">        # Handle the command</div>
<div class="line">        handle_command(data, handler, client_socket)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    handler.activeDCDataReady.disconnect()</div>
<div class="line">    handler.activeACDataReady.disconnect()</div>
<div class="line">    handler.experimentNewElementStarting.disconnect()</div>
<div class="line">    handler.experimentStopped.disconnect()</div>
<div class="line">    command_to_device(&quot;stopExperiment&quot;, handler)</div>
<div class="line">    # Close the client socket</div>
<div class="line">    client_socket.close()</div>
<div class="line">    print(&quot;Client disconnected&quot;)</div>
<div class="line">    os._exit(1)</div>
<div class="line"> </div>
<div class="line"># Send data the the client based on the type of event (Hooked up to signals)</div>
<div class="line">def send_data_to_client(client_socket, event_type, data):</div>
<div class="line">    if event_type == &quot;DCData&quot;:</div>
<div class="line">        message = &quot;timestamp: {:.9f}, workingElectrodeVoltage: {:.9f}&quot;.format(data.timestamp, data.workingElectrodeVoltage)</div>
<div class="line">    elif event_type == &quot;ACData&quot;:</div>
<div class="line">        message = &quot;frequency: {:.9f}, absoluteImpedance: {:.9f}, phaseAngle: {:.9f}&quot;.format(data.frequency, data.absoluteImpedance, data.phaseAngle)</div>
<div class="line">    elif event_type == &quot;NewElement&quot;:</div>
<div class="line">        message = &quot;New Node beginning: {}, step number: {}, step sub: {}&quot;.format(data.stepName, data.stepNumber, data.substepNumber)</div>
<div class="line">    elif event_type == &quot;ExperimentCompleted&quot;:</div>
<div class="line">        message = &quot;Experiment Completed: {}&quot;.format(data)</div>
<div class="line">    else:</div>
<div class="line">        return</div>
<div class="line"> </div>
<div class="line">    client_socket.send(message.encode())</div>
<div class="line"> </div>
<div class="line">def terminate_program():</div>
<div class="line">    print(&quot;Press &lt;CTRL&gt;+c to close the server&quot;)</div>
<div class="line">    try:</div>
<div class="line">        while True:</div>
<div class="line">            input()</div>
<div class="line">    except (EOFError, KeyboardInterrupt):</div>
<div class="line">        pass</div>
<div class="line">    for socket in activeSockets:</div>
<div class="line">        socket.close()</div>
<div class="line">    app.quit()</div>
<div class="line">    os._exit(1)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"># Create the device tracker and connect to the Squidstat we will be using</div>
<div class="line">print(f&quot;Attempting to connect to the Squidstat {SQUIDNAME} on {SQUIDCOMPORT}...&quot;)</div>
<div class="line">tracker = AisDeviceTracker.Instance()</div>
<div class="line">tracker.newDeviceConnected.connect(lambda deviceName: print(&quot;Device is Connected: %s&quot; % deviceName))</div>
<div class="line">error = tracker.connectToDeviceOnComPort(SQUIDCOMPORT)</div>
<div class="line"> </div>
<div class="line">if error.value() != AisErrorCode.ErrorCode.Success:</div>
<div class="line">    print(error.message())</div>
<div class="line">    exit()</div>
<div class="line"> </div>
<div class="line"># Create the instrument handler</div>
<div class="line">handler = tracker.getInstrumentHandler(SQUIDNAME)</div>
<div class="line">print(&quot;Connection successful\n&quot;)</div>
<div class="line"> </div>
<div class="line"># Create the TCP/IP socket and bind it to our host</div>
<div class="line">print(&quot;Starting server...&quot;)</div>
<div class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div>
<div class="line">activeSockets.append(server_socket)</div>
<div class="line">server_socket.bind((HOST, PORT))</div>
<div class="line"> </div>
<div class="line"># Listen for incoming connections</div>
<div class="line">server_socket.listen(1)</div>
<div class="line"> </div>
<div class="line">print(&quot;Server started successfully. Waiting for client connection...&quot;)</div>
<div class="line"> </div>
<div class="line">terminal_thread = threading.Thread(target=terminate_program)</div>
<div class="line">terminal_thread.start()</div>
<div class="line"> </div>
<div class="line"># Accept a client connection</div>
<div class="line">client_socket, client_address = server_socket.accept()</div>
<div class="line">activeSockets.append(client_socket)</div>
<div class="line"> </div>
<div class="line"># Connect the signals to send data to the client</div>
<div class="line">handler.activeDCDataReady.connect(lambda channel, data: send_data_to_client(client_socket, &quot;DCData&quot;, data))</div>
<div class="line">handler.activeACDataReady.connect(lambda channel, data: send_data_to_client(client_socket, &quot;ACData&quot;, data))</div>
<div class="line">handler.experimentNewElementStarting.connect(lambda channel, data: send_data_to_client(client_socket, &quot;NewElement&quot;, data))</div>
<div class="line">handler.experimentStopped.connect(lambda channel: send_data_to_client(client_socket, &quot;ExperimentCompleted&quot;, channel))</div>
<div class="line"> </div>
<div class="line"># Start the listening process in a separate thread</div>
<div class="line">listening_thread = threading.Thread(target=handle_client, args=(handler, client_socket))</div>
<div class="line">listening_thread.start()</div>
<div class="line"> </div>
<div class="line"># Start the QT event loop</div>
<div class="line">app.exec_()</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md25"></a>
TCP_Client.py</h4>
<div class="fragment"><div class="line">import os</div>
<div class="line">import socket</div>
<div class="line">import threading</div>
<div class="line">import time</div>
<div class="line"> </div>
<div class="line"># Create a TCP/IP socket</div>
<div class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div>
<div class="line">activeSockets = [client_socket]</div>
<div class="line"> </div>
<div class="line"># Define the server address and port</div>
<div class="line">SERVER_HOST = &quot;localhost&quot;</div>
<div class="line">SERVER_PORT = 12345</div>
<div class="line"> </div>
<div class="line"># Function to send a command to the server</div>
<div class="line">def send_command(command):</div>
<div class="line">    # Send the command to the server</div>
<div class="line">    try:</div>
<div class="line">        client_socket.send(command.encode())</div>
<div class="line">    except:</div>
<div class="line">        print(&quot;Connection was closed by host&quot;)</div>
<div class="line">        os._exit(1)</div>
<div class="line"> </div>
<div class="line">    # Receive and print the response from the server</div>
<div class="line">    response = client_socket.recv(1024).decode()</div>
<div class="line">    print(&quot;Server response:&quot;, response)</div>
<div class="line"> </div>
<div class="line">def interupt_listener():</div>
<div class="line">    print(&quot;Press &lt;CTRL&gt;+c to stop the program at any time.&quot;)</div>
<div class="line">    try:</div>
<div class="line">        while True:</div>
<div class="line">            input()</div>
<div class="line">    except (EOFError, KeyboardInterrupt):</div>
<div class="line">        pass</div>
<div class="line">    for socket in activeSockets:</div>
<div class="line">        socket.close()</div>
<div class="line">    os._exit(1)</div>
<div class="line"> </div>
<div class="line"># Try and open a socket to the server</div>
<div class="line">try:</div>
<div class="line">    client_socket.connect((SERVER_HOST, SERVER_PORT))</div>
<div class="line">except Exception as ex:</div>
<div class="line">    print(&quot;Unable to establish connection to server:\n%s&quot; % ex)</div>
<div class="line">    exit()</div>
<div class="line"> </div>
<div class="line">print(&quot;Connected to the server.&quot;)</div>
<div class="line"> </div>
<div class="line"># Get a duration from the user</div>
<div class="line">duration = 0</div>
<div class="line">while duration == 0:</div>
<div class="line">    try:</div>
<div class="line">        duration = int(input(&quot;Enter a duration for the Open Circuit Potential: &quot;))</div>
<div class="line">    except ValueError:</div>
<div class="line">        duration = 0</div>
<div class="line">    if(duration &lt; 1):</div>
<div class="line">        print(&quot;Invalid entry.&quot;)</div>
<div class="line">        duration = 0</div>
<div class="line"> </div>
<div class="line"># Send the start command to the server with the duration</div>
<div class="line">send_command(f&#39;startExperiment {duration}&#39;)</div>
<div class="line"> </div>
<div class="line">interupt_thread = threading.Thread(target=interupt_listener)</div>
<div class="line">interupt_thread.start()</div>
<div class="line"> </div>
<div class="line"># Listen for information from the server, which at this point will be data and the experiment stop message</div>
<div class="line">while True:</div>
<div class="line">    try:</div>
<div class="line">        data = client_socket.recv(1024).decode()</div>
<div class="line">    except (ConnectionAbortedError, BrokenPipeError):</div>
<div class="line">        # This exception will be raised when the user presses &lt;ENTER&gt;</div>
<div class="line">        print(&quot;Finishing connection&quot;)</div>
<div class="line">        break</div>
<div class="line">    except ConnectionResetError:</div>
<div class="line">        print(&quot;The server closed the connection suddenly.&quot;)</div>
<div class="line">        break</div>
<div class="line"> </div>
<div class="line">    if not data:</div>
<div class="line">        break</div>
<div class="line"> </div>
<div class="line">    # Handle the data that was received.</div>
<div class="line">    print(data)</div>
<div class="line"> </div>
<div class="line">    if(&quot;Experiment Completed: &quot; in data):</div>
<div class="line">        break</div>
<div class="line"> </div>
<div class="line">os._exit(1)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
